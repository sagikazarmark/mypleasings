def go_mod(name:str="go.mod", modfile:str="go.mod", deps:list=[], visibility:list=["PUBLIC"]):
    """References a go.mod file (along with its go.sum).

    Args:
      name (str): Name of the rule. Defaults to "go.mod".
      modfile (str): The name of the mod file. Defaults to "go.mod".
      deps (list): Dependencies (like other go.mod files from local replaces)
      visibility (list): Visibility of the rule.
    """

    assert modfile.endswith(".mod"), "Modfile must have .mod extension"

    sumfile = modfile[:-4] + ".sum"

    return filegroup(
        name = name,
        srcs = [modfile, sumfile],
        deps = deps,
        visibility = visibility,
    )

_GO_ENV_VARS = ["GOCACHE", "GODEBUG", "GOENV", "GOFLAGS", "GOINSECURE", "GOPROXY", "GOPRIVATE", "GONOPROXY", "GONOSUMDB", "GOSUMDB"]

CONFIG.setdefault("GOMOD", None)

def go_build(name:str, out:str=None, deps:list=[], visibility:list=None,
             test_only:bool&testonly=False, definitions:str|list|dict=None, stamp:bool=False,
             tags:list=[], trimpath:bool=False, pass_env:list=[], in_tree:bool=True):
    """Compiles a go binary.

    Args:
      name (str): Name of the rule.
      out (str): Name of the output file to create. Defaults to the same as `name`.
      deps (list): Dependencies
      visibility (list): Visibility of the rule.
      test_only (bool): If True, is only visible to test rules.
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
      stamp (bool): Allows this rule to gain access to information about SCM revision etc
                    via env vars. These can be useful to pass into `definitions`.
      tags (list): List of Go build tags passed to the build command.
      trimpath (bool): Remove all file system paths from the resulting executable.
      pass_env (list): List of environment variables to be passed from outside.
                       Any changes to them will be recorded in this target's hash and will hence force it to rebuild.
      in_tree (bool): Run the Go tool in the project root instead of the temp directory.
                      When False, you either have to set the GOMOD build config or pass your
                      go.mod and go.sum files as dependencies to the rule.
    """
    cmds, tools = _go_build_cmds("build", "", definitions, tags, trimpath, in_tree)

    if CONFIG.GOMOD:
        deps += [CONFIG.GOMOD]

    return build_rule(
        name = name,
        srcs = glob(["*.go"], exclude = ["*_test.go"]),
        deps = deps,
        outs = [out or name],
        cmd = cmds,
        tools = tools,
        pass_env = _GO_ENV_VARS + pass_env,
        building_description = "Compiling...",
        needs_transitive_deps = True,
        binary = True,
        test_only = test_only,
        visibility = visibility,
        requires = ["go"],
        stamp = stamp,
    )

def go_testx(name:str, srcs:list, deps:list=[], data:list=[], visibility:list=None,
             flags:str="", sandbox:bool=None, timeout:int=0, flaky:bool|int=0,
             test_outputs:list=None, labels:list&features&tags=None, size:str=None,
             tags:list=[], pass_env:list=[], in_tree:bool=True):
    """Defines a Go test rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files. Only used for determining if the target changed.
      deps (list): Dependencies
      data (list): Runtime data files for the test.
      visibility (list): Visibility of the rule.
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      tags (list): List of Go build tags passed to the build command.
      pass_env (list): List of environment variables to be passed from outside.
                       Any changes to them will be recorded in this target's hash and will hence force it to rebuild.
      in_tree (bool): Run the Go tool in the project root instead of the temp directory.
                      When False, you either have to set the GOMOD build config or pass your
                      go.mod and go.sum files as dependencies to the rule.
    """
    cmds, tools = _go_build_cmds("test", "-c", None, tags, False, in_tree)

    if flags.count("-test.v ") == 0 and not flags.endswith("-test.v"):
        flags += " -test.v"

    if CONFIG.GOMOD:
        deps += [CONFIG.GOMOD]

    return build_rule(
        name = name,
        srcs = srcs + glob(["*_test.go"]),
        deps = deps,
        outs = [name+".testbin"],
        cmd = cmds,
        tools = tools,
        data = data,
        test_cmd = 'cd "$(pwd | sed "s/plz-out\/.*//")/$PKG_DIR" && $TEST %s 2>&1 | tee "$RESULTS_FILE"' % flags,
        pass_env = _GO_ENV_VARS + pass_env,
        building_description = "Compiling...",
        needs_transitive_deps = True,
        output_is_complete=True,
        binary = True,
        labels = labels,
        test = True,
        test_sandbox = sandbox,
        test_timeout = timeout,
        size  =  size,
        flaky = flaky,
        test_outputs = test_outputs,
        visibility = visibility,
        requires = ["go", "test"],
    )

CONFIG.setdefault("GO_HOME", None)

def _go_build_cmds(cmd:str, args:str="", definitions:str|list|dict=None, tags:list=[], trimpath:bool, in_tree:bool):
    """Returns the commands to run for compiling a Go binary."""

    flags = f"{cmd} {args} -mod=readonly"

    if trimpath:
        flags += " -trimpath"

    if len(tags) > 0:
        flags += ' -tags "%s"' % ','.join(tags)

    if CONFIG.GOPATH.startswith("$TMP_DIR"): # When GOPATH is within the build directory, mod cache should be writable (best-effort)
        flags += " -modcacherw"

    linkerdefs = []
    if definitions is None:
        pass
    elif isinstance(definitions, str):
        linkerdefs += [f'{definitions}']
    elif isinstance(definitions, list):
        linkerdefs += [f'{linkerdef}' for linkerdef in definitions]
    elif isinstance(definitions, dict):
        linkerdefs = [k if v is None else f'{k}={v}' for k, v in sorted(definitions.items())]

    defs = " ".join([f'-X "{linkerdef}"' for linkerdef in linkerdefs])

    prefix_cmds = []

    if CONFIG.GO_HOME:
        prefix_cmds += [f'export HOME="{CONFIG.GO_HOME}"']

    gopath = CONFIG.GOPATH

    if not in_tree and gopath == "$TMP_DIR:$TMP_DIR/src:$TMP_DIR/$PKG_DIR:$TMP_DIR/third_party/go:$TMP_DIR/third_party/":
        prefix_cmds += ['mkdir -p "$TMP_DIR/plz-go"']
        gopath = "$TMP_DIR/plz-go"

    if gopath:
        prefix_cmds += [f'export GOPATH="{gopath}"']

    if in_tree:
        prefix_cmds += ['cd "$(pwd | sed "s/plz-out\/.*//")/$PKG_DIR"']
    else:
        prefix_cmds += ['mkdir -p "$TMP_DIR/plz-tmp"', 'export TMPDIR="$TMP_DIR/plz-tmp"', 'cd "$PKG_DIR"']

    cmds = {
        'dbg': " && ".join(prefix_cmds + [f'"$TOOLS_GO" {flags} -ldflags "{defs}" -o "$OUT"']),
        'opt': " && ".join(prefix_cmds + [f'"$TOOLS_GO" {flags} -ldflags "-s -w {defs}" -o "$OUT"']),
    }

    return cmds, {
        'go': [CONFIG.GO_TOOL],
    }
