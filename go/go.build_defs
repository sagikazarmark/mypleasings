_GO_ENV_VARS = ["GOPATH", "GOCACHE", "GODEBUG", "GOENV", "GOFLAGS", "GOINSECURE", "GOPROXY", "GOPRIVATE", "GONOPROXY", "GONOSUMDB", "GOSUMDB"]

def go_build(name:str, out:str=None, deps:list=[], visibility:list=None,
             test_only:bool&testonly=False, definitions:str|list|dict=None, stamp:bool=False,
             tags:list=[], trimpath:bool=False, pass_env:list=[], labels:list=[]):
    """Compiles a go binary.

    Args:
      name (str): Name of the rule.
      out (str): Name of the output file to create. Defaults to the same as `name`.
      deps (list): Dependencies
      visibility (list): Visibility of the rule.
      test_only (bool): If True, is only visible to test rules.
      definitions (str | list | dict): If set to a string, defines importpath.name=value
                     when calling the Go linker.  If set to a list, pass each value as a
                     definition to the linker.  If set to a dict, each key/value pair is
                     used to contruct the list of definitions passed to the linker.
      stamp (bool): Allows this rule to gain access to information about SCM revision etc
                    via env vars. These can be useful to pass into `definitions`.
      tags (list): List of Go build tags passed to the build command.
      trimpath (bool): Remove all file system paths from the resulting executable.
      pass_env (list): List of environment variables to be passed from outside.
                       Any changes to them will be recorded in this target's hash and will hence force it to rebuild.
      labels (list): Labels of this rule.
    """
    cmds, tools = _go_build_cmds("build", "", definitions, tags, trimpath)

    return build_rule(
        name = name,
        srcs = glob(["*.go"], exclude = ["*_test.go"]),
        deps = deps,
        outs = [out or name],
        cmd = cmds,
        tools = tools,
        pass_env = _GO_ENV_VARS + pass_env,
        building_description = "Compiling...",
        needs_transitive_deps = True,
        binary = True,
        test_only = test_only,
        visibility = visibility,
        requires = ["go"],
        stamp = stamp,
        labels = labels + ["go"],
    )

def go_testx(name:str, srcs:list, deps:list=[], data:list=[], visibility:list=None,
             flags:str="", sandbox:bool=None, timeout:int=0, flaky:bool|int=0,
             test_outputs:list=None, labels:list&features&tags=[], size:str=None,
             tags:list=[], pass_env:list=[]):
    """Defines a Go test rule.

    Args:
      name (str): Name of the rule.
      srcs (list): Go source files. Only used for determining if the target changed.
      deps (list): Dependencies
      data (list): Runtime data files for the test.
      visibility (list): Visibility of the rule.
      flags (str): Flags to apply to the test invocation.
      sandbox (bool): Sandbox the test on Linux to restrict access to namespaces such as network.
      timeout (int): Timeout in seconds to allow the test to run for.
      flaky (int | bool): True to mark the test as flaky, or an integer to specify how many reruns.
      test_outputs (list): Extra test output files to generate from this test.
      labels (list): Labels for this rule.
      size (str): Test size (enormous, large, medium or small).
      tags (list): List of Go build tags passed to the build command.
      pass_env (list): List of environment variables to be passed from outside.
                       Any changes to them will be recorded in this target's hash and will hence force it to rebuild.
    """
    cmds, tools = _go_build_cmds("test", "-c", None, tags, False)

    if flags.count("-test.v ") == 0 and not flags.endswith("-test.v"):
        flags += " -test.v"

    return build_rule(
        name = name,
        srcs = srcs,
        deps = deps,
        outs = [name+".testbin"],
        cmd = cmds,
        tools = tools,
        data = data,
        test_cmd = 'cd "$(pwd | sed "s/plz-out\/.*//")/$PKG_DIR" && $TEST %s 2>&1 | tee "$RESULTS_FILE"' % flags,
        pass_env = _GO_ENV_VARS + pass_env,
        building_description = "Compiling...",
        needs_transitive_deps = True,
        output_is_complete=True,
        binary = True,
        labels = labels + ["go"],
        test = True,
        test_sandbox = sandbox,
        test_timeout = timeout,
        size  =  size,
        flaky = flaky,
        test_outputs = test_outputs,
        visibility = visibility,
        requires = ["go", "test"],
    )

def _go_build_cmds(cmd:str, args:str="", definitions:str|list|dict=None, tags:list=[], trimpath:bool):
    """Returns the commands to run for compiling a Go binary."""

    flags = f"{cmd} {args} -mod=readonly"

    if trimpath:
        flags += " -trimpath"

    if len(tags) > 0:
        flags += ' -tags "%s"' % ','.join(tags)

    linkerdefs = []
    if definitions is None:
        pass
    elif isinstance(definitions, str):
        linkerdefs += [f'{definitions}']
    elif isinstance(definitions, list):
        linkerdefs += [f'{linkerdef}' for linkerdef in definitions]
    elif isinstance(definitions, dict):
        linkerdefs = [k if v is None else f'{k}={v}' for k, v in sorted(definitions.items())]

    defs = " ".join([f'-X "{linkerdef}"' for linkerdef in linkerdefs])

    prefix_cmds = []

    if CONFIG.GOPATH:
        prefix_cmds += [f'export GOPATH="{CONFIG.GOPATH}"']

    prefix_cmds += [
        'if [[ -z "$GOPATH" ]]; then export GOPATH=$(HOME="$(eval echo ~$(whoami))" GOPATH="" go env GOPATH); fi',
        'cd "$(pwd | sed "s/plz-out\/.*//")/$PKG_DIR"',
    ]

    cmds = {
        'dbg': " && ".join(prefix_cmds + [f'"$TOOLS_GO" {flags} -gcflags \"all=-N -l\" -ldflags "{defs}" -o "$OUT"']),
        'opt': " && ".join(prefix_cmds + [f'"$TOOLS_GO" {flags} -ldflags "-s -w {defs}" -o "$OUT"']),
    }

    return cmds, {
        'go': [CONFIG.GO_TOOL],
    }
